<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GalleryComponent V4 - VideoExpress Integration</title>
    <link rel="stylesheet" href="/components/GalleryComponent/GalleryComponent.css">
    <style>
        body, html { margin: 0; padding: 0; height: 100vh; background-color: #121212; }
        #gallery-container { height: 100vh; width: 100vw; }
        /* Simple loading overlay */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: flex; align-items: center;
            justify-content: center; color: white; z-index: 9999;
            font-size: 1.2rem;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <p>Connecting to server...</p>
    </div>
    <div id="gallery-container"></div>
    
    <script type="module">
        import GalleryComponent from './components/GalleryComponent/GalleryComponent.js';

        // --- Session, WebSocket, and API Helper ---
        const sessionId = `gallery-session_${Date.now()}`;
        const WS_URL = 'ws://localhost:3222';

        // --- Request Manager to handle async WebSocket responses ---
        const requestManager = {
            pendingRequests: new Map(),
            waitForResponse(type) {
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        this.pendingRequests.delete(type);
                        reject(new Error(`Request for '${type}' timed out after 10 seconds.`));
                    }, 10000);
                    this.pendingRequests.set(type, { resolve, reject, timeoutId });
                });
            },
            processMessage(message) {
                const resultType = message.payload?.result?.type;
                if (!resultType || !this.pendingRequests.has(resultType)) return;

                const { resolve, timeoutId } = this.pendingRequests.get(resultType);
                clearTimeout(timeoutId);
                this.pendingRequests.delete(resultType);
                resolve(message.payload.result.data);
            }
        };

        // --- WebSocket Connection (Promise-based) ---
        function connectWebSocket() {
            return new Promise((resolve, reject) => {
                const ws = new WebSocket(WS_URL);
                ws.onopen = () => {
                    console.log('[WebSocket] Connection established. Registering session...');
                    ws.send(JSON.stringify({ type: 'register', sessionId: sessionId }));
                };
                ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    console.log('[WebSocket] Message received from server:', message);
                    if (message.payload?.type === 'status' && message.payload?.message.includes('ConexiÃ³n con el servidor establecida')) {
                        console.log('[WebSocket] Session confirmed by server.');
                        resolve(); // Resolve promise on initial connection confirmation
                    } else {
                        // For all other messages, let the request manager handle them
                        requestManager.processMessage(message);
                    }
                };
                ws.onclose = () => {
                    console.log('[WebSocket] Connection closed.');
                    document.getElementById('loading-overlay').innerHTML = '<p>Connection Lost. Please refresh.</p>';
                };
                ws.onerror = (error) => {
                    console.error('[WebSocket] Error:', error);
                    reject(new Error("WebSocket connection failed."));
                };
            });
        }

        // --- API Helper for HTTP requests ---
        const apiHelper = {
            API_BASE_URL: 'http://localhost:3222/api',
            async _sendTask(macroName, params = {}) {
                const body = { ...params, sessionId };
                const response = await fetch(`${this.API_BASE_URL}/${macroName}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `Server error: ${response.status}`);
                }
                return true;
            }
        };

        // --- Main App Initialization (Async) ---
        async function main() {
            try {
                await connectWebSocket();
                document.getElementById('loading-overlay').style.display = 'none';

                new GalleryComponent('#gallery-container', {
                    foldersAllowed: true,
                    dataSource: {
                        // --- FOLDER METHODS ---
                        async onLoadFolders() {
                            console.log("[DataSource] Requesting folder list task...");
                            await apiHelper._sendTask('list-categories');
                            // Wait for the response to arrive via WebSocket
                            const categories = await requestManager.waitForResponse('category_list');
                            
                            const folders = categories.map(cat => ({
                                id: cat.id,
                                name: cat.title,
                                metadata: { originalName: cat.name }
                            }));
                            this._internalFolders = folders;
                            return folders;
                        },

                        async onCreateFolder(name) {
                            await apiHelper._sendTask('create-category', { categoryName: name });
                            // Wait for the confirmation/refresh message from the socket
                            await requestManager.waitForResponse('category_list_refreshed');
                        },

                        async onRenameFolder(folderId, newName) {
                            await apiHelper._sendTask('rename-category', { categoryId: folderId, newCategoryName: newName });
                            await requestManager.waitForResponse('category_list_refreshed');
                        },

                        async onDeleteFolder(folderId) {
                            await apiHelper._sendTask('delete-category', { categoryId: folderId });
                            await requestManager.waitForResponse('category_list_refreshed');
                        },

                        // --- ITEM METHODS ---
                        async onLoadItems(folderId) {
                            console.log(`[DataSource] Loading items for folder: ${folderId}`);
                            if (!folderId) return [];

                            const currentFolder = this._internalFolders.find(f => f.id == folderId);
                            if (!currentFolder) return [];
                            
                            await apiHelper._sendTask('list-gallery-items', { GALLERY_FOLDER: currentFolder.metadata.originalName });
                            const items = await requestManager.waitForResponse('gallery_list');

                            return items.map(item => ({
                                id: item.id, name: item.name, thumbUrl: item.thumbUrl,
                                mediaUrl: item.mediaPath, type: item.type, metadata: { ...item }
                            }));
                        },

                        async onRenameItem(itemId, newName, context) {
                            await apiHelper._sendTask('rename-media-item', { 
                                mediaId: itemId, newName: newName,
                                GALLERY_FOLDER: context.currentFolder.metadata.originalName 
                            });
                             await requestManager.waitForResponse('gallery_refreshed');
                        },
                        
                        async onDeleteItem(itemIds, context) {
                            await apiHelper._sendTask('delete-multiple-items', { 
                                mediaIds: itemIds,
                                GALLERY_FOLDER: context.currentFolder.metadata.originalName
                            });
                             await requestManager.waitForResponse('gallery_refreshed');
                        },

                        async onMoveItem(itemIds, destinationFolderId, context) {
                             await apiHelper._sendTask('move-multiple-items', {
                                mediaIds: itemIds, targetCategoryId: destinationFolderId,
                                GALLERY_FOLDER: context.currentFolder.metadata.originalName
                            });
                             await requestManager.waitForResponse('gallery_refreshed');
                        },
                        
                        _internalFolders: [],
                    }
                });
            } catch (error) {
                const loadingOverlay = document.getElementById('loading-overlay');
                loadingOverlay.innerHTML = `<p>Connection Failed: ${error.message}</p>`;
                console.error("Initialization failed:", error);
            }
        }
        
        main();

    </script>
</body>
</html>

